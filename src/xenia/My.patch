diff --git a/app/emulator_window.cc b/app/emulator_window.cc
index 971f889..14e5c07 100644
--- a/app/emulator_window.cc
+++ b/app/emulator_window.cc
@@ -25,7 +25,6 @@
 #include "xenia/ui/file_picker.h"
 #include "xenia/ui/imgui_dialog.h"
 #include "xenia/ui/imgui_drawer.h"
-#include "xenia/ui/virtual_key.h"
 
 // Autogenerated by `xb premake`.
 #include "build/version.h"
@@ -92,48 +91,48 @@ bool EmulatorWindow::Initialize() {
 
   window_->on_key_down.AddListener([this](KeyEvent* e) {
     bool handled = true;
-    switch (e->virtual_key()) {
-      case ui::VirtualKey::kO: {
+    switch (e->key_code()) {
+      case 0x4F: {  // o
         if (e->is_ctrl_pressed()) {
           FileOpen();
         }
       } break;
-      case ui::VirtualKey::kMultiply: {
+      case 0x6A: {  // numpad *
         CpuTimeScalarReset();
       } break;
-      case ui::VirtualKey::kSubtract: {
+      case 0x6D: {  // numpad minus
         CpuTimeScalarSetHalf();
       } break;
-      case ui::VirtualKey::kAdd: {
+      case 0x6B: {  // numpad plus
         CpuTimeScalarSetDouble();
       } break;
 
-      case ui::VirtualKey::kF3: {
+      case 0x72: {  // F3
         Profiler::ToggleDisplay();
       } break;
 
-      case ui::VirtualKey::kF4: {
+      case 0x73: {  // VK_F4
         GpuTraceFrame();
       } break;
-      case ui::VirtualKey::kF5: {
+      case 0x74: {  // VK_F5
         GpuClearCaches();
       } break;
-      case ui::VirtualKey::kF7: {
+      case 0x76: {  // VK_F7
         // Save to file
         // TODO: Choose path based on user input, or from options
         // TODO: Spawn a new thread to do this.
         emulator()->SaveToFile("test.sav");
       } break;
-      case ui::VirtualKey::kF8: {
+      case 0x77: {  // VK_F8
         // Restore from file
         // TODO: Choose path from user
         // TODO: Spawn a new thread to do this.
         emulator()->RestoreFromFile("test.sav");
       } break;
-      case ui::VirtualKey::kF11: {
+      case 0x7A: {  // VK_F11
         ToggleFullscreen();
       } break;
-      case ui::VirtualKey::kEscape: {
+      case 0x1B: {  // VK_ESCAPE
         // Allow users to escape fullscreen (but not enter it).
         if (window_->is_fullscreen()) {
           window_->ToggleFullscreen(false);
@@ -142,18 +141,18 @@ bool EmulatorWindow::Initialize() {
         }
       } break;
 
-      case ui::VirtualKey::kPause: {
+      case 0x13: {  // VK_PAUSE
         CpuBreakIntoDebugger();
       } break;
-      case ui::VirtualKey::kCancel: {
+      case 0x03: {  // VK_CANCEL
         CpuBreakIntoHostDebugger();
       } break;
 
-      case ui::VirtualKey::kF1: {
+      case 0x70: {  // VK_F1
         ShowHelpWebsite();
       } break;
 
-      case ui::VirtualKey::kF2: {
+      case 0x71: {  // VK_F2
         ShowCommitID();
       } break;
 
@@ -165,13 +164,14 @@ bool EmulatorWindow::Initialize() {
   });
 
   window_->on_mouse_move.AddListener([this](MouseEvent* e) {
+    /*
     if (window_->is_fullscreen() && (e->dx() > 2 || e->dy() > 2)) {
       if (!window_->is_cursor_visible()) {
         window_->set_cursor_visible(true);
       }
 
       cursor_hide_time_ = Clock::QueryHostSystemTime() + 30000000;
-    }
+    }*/
 
     e->set_handled(false);
   });
@@ -415,7 +415,7 @@ void EmulatorWindow::ToggleFullscreen() {
   window_->ToggleFullscreen(!window_->is_fullscreen());
 
   // Hide the cursor after a second if we're going fullscreen
-  cursor_hide_time_ = Clock::QueryHostSystemTime() + 30000000;
+  cursor_hide_time_ = Clock::QueryHostSystemTime() + 15000000;
   if (!window_->is_fullscreen()) {
     window_->set_cursor_visible(true);
   }
diff --git a/app/xenia_main.cc b/app/xenia_main.cc
index 39a2a72..6285472 100644
--- a/app/xenia_main.cc
+++ b/app/xenia_main.cc
@@ -255,14 +255,14 @@ std::vector<std::unique_ptr<hid::InputDriver>> EmulatorApp::CreateInputDrivers(
     drivers.emplace_back(xe::hid::nop::Create(window));
   } else {
     Factory<hid::InputDriver, ui::Window*> factory;
-#if XE_PLATFORM_WIN32
-    factory.Add("xinput", xe::hid::xinput::Create);
-#endif  // XE_PLATFORM_WIN32
-    factory.Add("sdl", xe::hid::sdl::Create);
 #if XE_PLATFORM_WIN32
     // WinKey input driver should always be the last input driver added!
     factory.Add("winkey", xe::hid::winkey::Create);
 #endif  // XE_PLATFORM_WIN32
+#if XE_PLATFORM_WIN32
+    factory.Add("xinput", xe::hid::xinput::Create);
+#endif  // XE_PLATFORM_WIN32
+    factory.Add("sdl", xe::hid::sdl::Create);
     for (auto& driver : factory.CreateAll(cvars::hid, window)) {
       if (XSUCCEEDED(driver->Setup())) {
         drivers.emplace_back(std::move(driver));
diff --git a/base/profiling.cc b/base/profiling.cc
index bf24d4f..2305717 100644
--- a/base/profiling.cc
+++ b/base/profiling.cc
@@ -30,7 +30,6 @@
 #include "xenia/base/assert.h"
 #include "xenia/base/cvar.h"
 #include "xenia/base/profiling.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/window.h"
 
 #if XE_OPTION_PROFILING
@@ -113,17 +112,17 @@ void Profiler::ThreadEnter(const char* name) {
 
 void Profiler::ThreadExit() { MicroProfileOnThreadExit(); }
 
-bool Profiler::OnKeyDown(ui::VirtualKey virtual_key) {
+bool Profiler::OnKeyDown(int key_code) {
   // https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
-  switch (virtual_key) {
-    case ui::VirtualKey::kOem3:  // `
+  switch (key_code) {
+    case VK_OEM_3:  // `
       MicroProfileTogglePause();
       return true;
 #if XE_OPTION_PROFILING_UI
-    case ui::VirtualKey::kTab:
+    case VK_TAB:
       MicroProfileToggleDisplayMode();
       return true;
-    case ui::VirtualKey::k1:
+    case 0x31:  // 1
       MicroProfileModKey(1);
       return true;
 #endif  // XE_OPTION_PROFILING_UI
@@ -133,15 +132,13 @@ bool Profiler::OnKeyDown(ui::VirtualKey virtual_key) {
   return false;
 }
 
-bool Profiler::OnKeyUp(ui::VirtualKey virtual_key) {
-  switch (virtual_key) {
+bool Profiler::OnKeyUp(int key_code) {
+  switch (key_code) {
 #if XE_OPTION_PROFILING_UI
-    case ui::VirtualKey::k1:
+    case 0x31:  // 1
       MicroProfileModKey(0);
       return true;
 #endif  // XE_OPTION_PROFILING_UI
-    default:
-      break;
   }
   return false;
 }
@@ -224,14 +221,14 @@ void Profiler::set_window(ui::Window* window) {
   // Watch for toggle/mode keys and such.
   window_->on_key_down.AddListener([](ui::KeyEvent* e) {
     if (Profiler::is_visible()) {
-      Profiler::OnKeyDown(e->virtual_key());
+      Profiler::OnKeyDown(e->key_code());
       e->set_handled(true);
       window_->Invalidate();
     }
   });
   window_->on_key_up.AddListener([](ui::KeyEvent* e) {
     if (Profiler::is_visible()) {
-      Profiler::OnKeyUp(e->virtual_key());
+      Profiler::OnKeyUp(e->key_code());
       e->set_handled(true);
       window_->Invalidate();
     }
@@ -262,8 +259,8 @@ void Profiler::Shutdown() {}
 uint32_t Profiler::GetColor(const char* str) { return 0; }
 void Profiler::ThreadEnter(const char* name) {}
 void Profiler::ThreadExit() {}
-bool Profiler::OnKeyDown(ui::VirtualKey virtual_key) { return false; }
-bool Profiler::OnKeyUp(ui::VirtualKey virtual_key) { return false; }
+bool Profiler::OnKeyDown(int key_code) { return false; }
+bool Profiler::OnKeyUp(int key_code) { return false; }
 void Profiler::OnMouseDown(bool left_button, bool right_button) {}
 void Profiler::OnMouseUp() {}
 void Profiler::OnMouseMove(int x, int y) {}
diff --git a/base/profiling.h b/base/profiling.h
index a55600d..d6cc42d 100644
--- a/base/profiling.h
+++ b/base/profiling.h
@@ -13,7 +13,6 @@
 #include <memory>
 
 #include "xenia/base/string.h"
-#include "xenia/ui/virtual_key.h"
 
 #if XE_PLATFORM_WIN32
 #define XE_OPTION_PROFILING 1
@@ -172,8 +171,8 @@ class Profiler {
   // Deactivates the calling thread for profiling.
   static void ThreadExit();
 
-  static bool OnKeyDown(ui::VirtualKey virtual_key);
-  static bool OnKeyUp(ui::VirtualKey virtual_key);
+  static bool OnKeyDown(int key_code);
+  static bool OnKeyUp(int key_code);
   static void OnMouseDown(bool left_button, bool right_button);
   static void OnMouseUp();
   static void OnMouseMove(int x, int y);
diff --git a/config.cc b/config.cc
index 1618a7d..7b4dea2 100644
--- a/config.cc
+++ b/config.cc
@@ -46,7 +46,7 @@ DEFINE_uint32(
     "Config");
 
 namespace config {
-std::string config_name = "xenia-canary.config.toml";
+std::string config_name = "xenia-mousehook.config.toml";
 std::filesystem::path config_folder;
 std::filesystem::path config_path;
 std::string game_config_suffix = ".config.toml";
diff --git a/emulator.cc b/emulator.cc
index 982a949..caa176b 100644
--- a/emulator.cc
+++ b/emulator.cc
@@ -58,6 +58,11 @@ DEFINE_string(
     "module.",
     "General");
 
+DEFINE_bool(ge_remove_blur, false,
+            "(GoldenEye) Removes low-res blur when in classic-graphics mode", "MouseHook");
+DEFINE_bool(ge_debug_menu, false,
+            "(GoldenEye) Enables the debug menu, accessible with LB/1", "MouseHook");
+
 namespace xe {
 
 Emulator::Emulator(const std::filesystem::path& command_line,
@@ -700,6 +705,7 @@ X_STATUS Emulator::CompleteLaunch(const std::filesystem::path& path,
   title_id_ = std::nullopt;
   title_name_ = "";
   title_version_ = "";
+  executable_path_.clear();
   display_window_->SetIcon(nullptr, 0);
 
   // Allow xam to request module loads.
@@ -712,6 +718,8 @@ X_STATUS Emulator::CompleteLaunch(const std::filesystem::path& path,
     return X_STATUS_NOT_FOUND;
   }
 
+  executable_path_ = path;
+
   // Grab the current title ID.
   xex2_opt_execution_info* info = nullptr;
   module->GetOptHeader(XEX_HEADER_EXECUTION_INFO, &info);
@@ -748,9 +756,139 @@ X_STATUS Emulator::CompleteLaunch(const std::filesystem::path& path,
           display_window_->SetIcon(icon_block.buffer, icon_block.size);
         }
       }
+    }
+
+    auto patch_addr = [module](uint32_t addr, uint32_t value) {
+        auto* patch_ptr =
+            (xe::be<uint32_t>*)module->memory()->TranslateVirtual(addr);
+        auto heap = module->memory()->LookupHeap(addr);
+
+        uint32_t old_protect = 0;
+        heap->Protect(addr, 4, kMemoryProtectRead | kMemoryProtectWrite,
+                      &old_protect);
+        *patch_ptr = value;
+        heap->Protect(addr, 4, old_protect);
+      };
+
+      if (module->title_id() == 0x584109C2) {
+        // Prevent game from writing RS thumbstick to crosshair/gun position
+        // Multiple PD revisions so we'll need to search the code...
+
+        std::vector<uint32_t> search_insns = {
+            0xD17F16A8,  // stfs      f11, 0x16A8(r31)
+            0xD19F16A4,  // stfs      f12, 0x16A4(r31)
+            0xD19F1690,  // stfs      f12, 0x1690(r31)
+            0xD15F1694,  // stfs      f10, 0x1694(r31)
+            0xD0FF0CFC,  // stfs      f7, 0xCFC(r31)
+            0xD0BF0D00   // stfs      f5, 0xD00(r31)
+        };
+
+        int patched = 0;
+
+        auto* xex = module->xex_module();
+        auto* check_addr =
+            (xe::be<uint32_t>*)module->memory()->TranslateVirtual(
+                xex->base_address());
+        auto* end_addr = (xe::be<uint32_t>*)module->memory()->TranslateVirtual(
+            xex->base_address() + xex->image_size());
+
+        while (end_addr > check_addr) {
+          auto value = *check_addr;
+
+          for (auto test : search_insns) {
+            if (test == value) {
+              uint32_t addr = module->memory()->HostToGuestVirtual(check_addr);
+              patch_addr(addr, 0x60000000);
+              patched++;
+              break;
+            }
+          }
+
+          check_addr++;
+        }
+      }
+
+      if (module->title_id() == 0x584108A9) {
+        struct GEPatchOffsets {
+          uint32_t check_addr;
+          uint32_t check_value;
+
+          uint32_t crosshair_addr1;
+          uint32_t crosshair_patch1;
+          uint32_t crosshair_addr2;
+          uint32_t crosshair_patch2;
+
+          uint32_t returnarcade_addr1;
+          uint32_t returnarcade_patch1;
+          uint32_t returnarcade_addr2;
+          uint32_t returnarcade_patch2;
+          uint32_t returnarcade_addr3;
+          uint32_t returnarcade_patch3;
+
+          uint32_t blur_addr;
+          uint32_t debug_addr;
+        };
+
+        std::vector<GEPatchOffsets> supported_builds = {
+            // Nov 2007 Release build
+            {0x8200336C, 0x676f6c64, 0x820A45D0, 0x4800003C, 0x820A46D4,
+             0x4800003C, 0x820F7750, 0x2F1E0007, 0x820F7D04, 0x2F1A0007,
+             0x820F7780, 0x2B0A0003, 0x82188E70, 0x82189F28},
+
+            // Nov 2007 Team build
+            {0x82003398, 0x676f6c64, 0x820C85B0, 0x480000B0, 0x820C88B8,
+             0x480000B0, 0x8213ABE8, 0x2F0B0007, 0x8213AF0C, 0x2F0B0007,
+             0x8213ACB4, 0x2B0B0004, 0x8221DF34, 0},
+
+            // Nov 2007 Debug build
+            {0x82005540, 0x676f6c64, 0x822A2BFC, 0x480000B0, 0x822A2F04,
+             0x480000B0, 0x82344D04, 0x2F0B0007, 0x82345030, 0x2F0B0007,
+             0x82344DD0, 0x2B0B0004, 0x824AB510, 0},
+        };
+
+        for (auto& build : supported_builds) {
+          auto* test_addr =
+              (xe::be<uint32_t>*)module->memory()->TranslateVirtual(
+                  build.check_addr);
+          if (*test_addr != build.check_value) {
+            continue;
+          }
 
-      patching_system_->ApplyPatchesForTitle(
-          kernel_state()->memory(), module->title_id(), module->hash());
+          // Prevent game from overwriting crosshair/gun positions
+          if (build.crosshair_addr1) {
+            patch_addr(build.crosshair_addr1, build.crosshair_patch1);
+          }
+          if (build.crosshair_addr2) {
+            patch_addr(build.crosshair_addr2, build.crosshair_patch2);
+          }
+
+          // Hide "return to arcade" menu option
+          if (build.returnarcade_addr1) {
+            patch_addr(build.returnarcade_addr1, build.returnarcade_patch1);
+          }
+          if (build.returnarcade_addr2) {
+            patch_addr(build.returnarcade_addr2, build.returnarcade_patch2);
+          }
+          // Prevent "return to arcade" code from being executed
+          if (build.returnarcade_addr3) {
+            patch_addr(build.returnarcade_addr3, build.returnarcade_patch3);
+          }
+
+          if (cvars::ge_remove_blur && build.blur_addr) {
+            // Patch out N64 blur
+            // Source:
+            // https://github.com/xenia-canary/game-patches/blob/main/patches/584108A9.patch
+
+            patch_addr(build.blur_addr, 0x60000000);
+          }
+
+          if (cvars::ge_debug_menu && build.debug_addr) {
+            // Enable debug menu
+            patch_addr(build.debug_addr, 0x2B0B0000);
+          }
+
+          break;
+        }
     }
   }
 
diff --git a/emulator.h b/emulator.h
index 30b00ac..0fb8b89 100644
--- a/emulator.h
+++ b/emulator.h
@@ -75,6 +75,11 @@ class Emulator {
   // Version of the title as a string.
   const std::string& title_version() const { return title_version_; }
 
+  // Host path of the executable being ran
+  const std::filesystem::path& executable_path() const {
+    return executable_path_;
+  }
+
   // Currently running title ID
   uint32_t title_id() const {
     return !title_id_.has_value() ? 0 : title_id_.value();
@@ -184,6 +189,7 @@ class Emulator {
   std::filesystem::path storage_root_;
   std::filesystem::path content_root_;
   std::filesystem::path cache_root_;
+  std::filesystem::path executable_path_;
 
   std::string title_name_;
   std::string title_version_;
diff --git a/gpu/trace_viewer.cc b/gpu/trace_viewer.cc
index d5f3892..a00c5f8 100644
--- a/gpu/trace_viewer.cc
+++ b/gpu/trace_viewer.cc
@@ -30,7 +30,6 @@
 #include "xenia/memory.h"
 #include "xenia/ui/file_picker.h"
 #include "xenia/ui/imgui_drawer.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/window.h"
 #include "xenia/ui/windowed_app_context.h"
 #include "xenia/xbox.h"
@@ -128,7 +127,7 @@ bool TraceViewer::Setup() {
   window_->set_imgui_input_enabled(true);
 
   window_->on_key_char.AddListener([&](xe::ui::KeyEvent* e) {
-    if (e->virtual_key() == xe::ui::VirtualKey::kF5) {
+    if (e->key_code() == 0x74 /* VK_F5 */) {
       graphics_system_->ClearCaches();
       e->set_handled(true);
     }
diff --git a/hid/hid_demo.cc b/hid/hid_demo.cc
index d02735a..597b7e8 100644
--- a/hid/hid_demo.cc
+++ b/hid/hid_demo.cc
@@ -10,10 +10,10 @@
 #include <array>
 #include <cstring>
 #include <forward_list>
+#include <map>
 #include <memory>
 #include <string>
 #include <tuple>
-#include <unordered_map>
 #include <vector>
 
 #include "third_party/fmt/include/fmt/format.h"
@@ -25,7 +25,6 @@
 #include "xenia/hid/hid_flags.h"
 #include "xenia/hid/input_system.h"
 #include "xenia/ui/imgui_drawer.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/vulkan/vulkan_provider.h"
 #include "xenia/ui/window.h"
 #include "xenia/ui/windowed_app.h"
@@ -49,6 +48,8 @@ DEFINE_string(hid, "any", "Input system. Use: [any, nop, sdl, winkey, xinput]",
 namespace xe {
 namespace hid {
 
+std::unique_ptr<xe::hid::InputSystem> input_system_;
+
 class HidDemoApp final : public ui::WindowedApp {
  public:
   static std::unique_ptr<ui::WindowedApp> Create(
@@ -67,8 +68,7 @@ class HidDemoApp final : public ui::WindowedApp {
 
   void DrawUserInputGetState(uint32_t user_index) const;
   void DrawInputGetState() const;
-  void DrawUserInputGetKeystroke(uint32_t user_index, bool poll,
-                                 bool hide_repeats, bool clear_log) const;
+
   void DrawInputGetKeystroke(bool poll, bool hide_repeats,
                              bool clear_log) const;
 
@@ -289,48 +289,45 @@ void HidDemoApp::DrawInputGetState() const {
   ImGui::EndChild();
 }
 
-void HidDemoApp::DrawUserInputGetKeystroke(uint32_t user_index, bool poll,
-                                           bool hide_repeats,
-                                           bool clear_log) const {
-  static const std::unordered_map<ui::VirtualKey, const std::string> kVkPretty =
-      {
-          {ui::VirtualKey::kXInputPadA, "A"},
-          {ui::VirtualKey::kXInputPadB, "B"},
-          {ui::VirtualKey::kXInputPadX, "X"},
-          {ui::VirtualKey::kXInputPadY, "Y"},
-          {ui::VirtualKey::kXInputPadRShoulder, "R Shoulder"},
-          {ui::VirtualKey::kXInputPadLShoulder, "L Shoulder"},
-          {ui::VirtualKey::kXInputPadLTrigger, "L Trigger"},
-          {ui::VirtualKey::kXInputPadRTrigger, "R Trigger"},
-
-          {ui::VirtualKey::kXInputPadDpadUp, "DPad up"},
-          {ui::VirtualKey::kXInputPadDpadDown, "DPad down"},
-          {ui::VirtualKey::kXInputPadDpadLeft, "DPad left"},
-          {ui::VirtualKey::kXInputPadDpadRight, "DPad right"},
-          {ui::VirtualKey::kXInputPadStart, "Start"},
-          {ui::VirtualKey::kXInputPadBack, "Back"},
-          {ui::VirtualKey::kXInputPadLThumbPress, "L Thumb press"},
-          {ui::VirtualKey::kXInputPadRThumbPress, "R Thumb press"},
-
-          {ui::VirtualKey::kXInputPadLThumbUp, "L Thumb up"},
-          {ui::VirtualKey::kXInputPadLThumbDown, "L Thumb down"},
-          {ui::VirtualKey::kXInputPadLThumbRight, "L Thumb right"},
-          {ui::VirtualKey::kXInputPadLThumbLeft, "L Thumb left"},
-          {ui::VirtualKey::kXInputPadLThumbUpLeft, "L Thumb up & left"},
-          {ui::VirtualKey::kXInputPadLThumbUpRight, "L Thumb up & right"},
-          {ui::VirtualKey::kXInputPadLThumbDownRight, "L Thumb down & right"},
-          {ui::VirtualKey::kXInputPadLThumbDownLeft, "L Thumb down & left"},
-
-          {ui::VirtualKey::kXInputPadRThumbUp, "R Thumb up"},
-          {ui::VirtualKey::kXInputPadRThumbDown, "R Thumb down"},
-          {ui::VirtualKey::kXInputPadRThumbRight, "R Thumb right"},
-          {ui::VirtualKey::kXInputPadRThumbLeft, "R Thumb left"},
-          {ui::VirtualKey::kXInputPadRThumbUpLeft, "R Thumb up & left"},
-          {ui::VirtualKey::kXInputPadRThumbUpRight, "R Thumb up & right"},
-          {ui::VirtualKey::kXInputPadRThumbDownRight, "R Thumb down & right"},
-          {ui::VirtualKey::kXInputPadRThumbDownLeft, "R Thumb down & left"},
-      };
+static const std::map<std::underlying_type<X_INPUT_GAMEPAD_VK>::type,
+                      const std::string>
+    vk_pretty = {
+        {X_INPUT_GAMEPAD_VK_A, "A"}, {X_INPUT_GAMEPAD_VK_B, "B"},
+        {X_INPUT_GAMEPAD_VK_X, "X"}, {X_INPUT_GAMEPAD_VK_Y, "Y"},
+        {X_INPUT_GAMEPAD_VK_RSHOULDER, "R Shoulder"},
+        {X_INPUT_GAMEPAD_VK_LSHOULDER, "L Shoulder"},
+        {X_INPUT_GAMEPAD_VK_LTRIGGER, "L Trigger"},
+        {X_INPUT_GAMEPAD_VK_RTRIGGER, "R Trigger"},
+
+        {X_INPUT_GAMEPAD_VK_DPAD_UP, "DPad up"},
+        {X_INPUT_GAMEPAD_VK_DPAD_DOWN, "DPad down"},
+        {X_INPUT_GAMEPAD_VK_DPAD_LEFT, "DPad left"},
+        {X_INPUT_GAMEPAD_VK_DPAD_RIGHT, "DPad right"},
+        {X_INPUT_GAMEPAD_VK_START, "Start"}, {X_INPUT_GAMEPAD_VK_BACK, "Back"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_PRESS, "L Thumb press"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_PRESS, "R Thumb press"},
+
+        {X_INPUT_GAMEPAD_VK_LTHUMB_UP, "L Thumb up"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_DOWN, "L Thumb down"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_RIGHT, "L Thumb right"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_LEFT, "L Thumb left"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_UPLEFT, "L Thumb up & left"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_UPRIGHT, "L Thumb up & right"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_DOWNRIGHT, "L Thumb down & right"},
+        {X_INPUT_GAMEPAD_VK_LTHUMB_DOWNLEFT, "L Thumb down & left"},
+
+        {X_INPUT_GAMEPAD_VK_RTHUMB_UP, "R Thumb up"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_DOWN, "R Thumb down"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_RIGHT, "R Thumb right"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_LEFT, "R Thumb left"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_UPLEFT, "R Thumb up & left"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_UPRIGHT, "R Thumb up & right"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_DOWNRIGHT, "R Thumb down & right"},
+        {X_INPUT_GAMEPAD_VK_RTHUMB_DOWNLEFT, "R Thumb down & left"},
+};
 
+void DrawUserInputGetKeystroke(uint32_t user_index, bool poll,
+                               bool hide_repeats, bool clear_log) {
   const size_t maxLog = 128;
   static std::array<std::forward_list<std::string>, MAX_USERS> event_logs;
   static std::array<uint64_t, MAX_USERS> last_event_times = {};
@@ -362,12 +359,10 @@ void HidDemoApp::DrawUserInputGetKeystroke(uint32_t user_index, bool poll,
             break;
           }
 
-          ui::VirtualKey virtual_key = ui::VirtualKey(stroke.virtual_key.get());
-          const auto key_search = kVkPretty.find(virtual_key);
-          std::string key =
-              key_search != kVkPretty.cend()
-                  ? key_search->second
-                  : fmt::format("0x{:04x}", uint16_t(virtual_key));
+          const auto key_search = vk_pretty.find(stroke.virtual_key);
+          const auto key = key_search != vk_pretty.end()
+                               ? key_search->second
+                               : fmt::format("0x{:04x}", stroke.virtual_key);
           event_log.emplace_front(fmt::format(
               "{:>6} {:>9}ms    {:<20}    {} {} {}", ImGui::GetFrameCount(),
               dur, key,
diff --git a/hid/input.h b/hid/input.h
index 82202a3..9ebec01 100644
--- a/hid/input.h
+++ b/hid/input.h
@@ -46,7 +46,43 @@ enum X_INPUT_GAMEPAD_BUTTON {
   X_INPUT_GAMEPAD_Y = 0x8000,
 };
 
-// For VK_PAD, use ui::VirtualKey.
+enum X_INPUT_GAMEPAD_VK {
+  X_INPUT_GAMEPAD_VK_A = 0x5800,
+  X_INPUT_GAMEPAD_VK_B = 0x5801,
+  X_INPUT_GAMEPAD_VK_X = 0x5802,
+  X_INPUT_GAMEPAD_VK_Y = 0x5803,
+  X_INPUT_GAMEPAD_VK_RSHOULDER = 0x5804,
+  X_INPUT_GAMEPAD_VK_LSHOULDER = 0x5805,
+  X_INPUT_GAMEPAD_VK_LTRIGGER = 0x5806,
+  X_INPUT_GAMEPAD_VK_RTRIGGER = 0x5807,
+
+  X_INPUT_GAMEPAD_VK_DPAD_UP = 0x5810,
+  X_INPUT_GAMEPAD_VK_DPAD_DOWN = 0x5811,
+  X_INPUT_GAMEPAD_VK_DPAD_LEFT = 0x5812,
+  X_INPUT_GAMEPAD_VK_DPAD_RIGHT = 0x5813,
+  X_INPUT_GAMEPAD_VK_START = 0x5814,
+  X_INPUT_GAMEPAD_VK_BACK = 0x5815,
+  X_INPUT_GAMEPAD_VK_LTHUMB_PRESS = 0x5816,
+  X_INPUT_GAMEPAD_VK_RTHUMB_PRESS = 0x5817,
+
+  X_INPUT_GAMEPAD_VK_LTHUMB_UP = 0x5820,
+  X_INPUT_GAMEPAD_VK_LTHUMB_DOWN = 0x5821,
+  X_INPUT_GAMEPAD_VK_LTHUMB_RIGHT = 0x5822,
+  X_INPUT_GAMEPAD_VK_LTHUMB_LEFT = 0x5823,
+  X_INPUT_GAMEPAD_VK_LTHUMB_UPLEFT = 0x5824,
+  X_INPUT_GAMEPAD_VK_LTHUMB_UPRIGHT = 0x5825,
+  X_INPUT_GAMEPAD_VK_LTHUMB_DOWNRIGHT = 0x5826,
+  X_INPUT_GAMEPAD_VK_LTHUMB_DOWNLEFT = 0x5827,
+
+  X_INPUT_GAMEPAD_VK_RTHUMB_UP = 0x5830,
+  X_INPUT_GAMEPAD_VK_RTHUMB_DOWN = 0x5831,
+  X_INPUT_GAMEPAD_VK_RTHUMB_RIGHT = 0x5832,
+  X_INPUT_GAMEPAD_VK_RTHUMB_LEFT = 0x5833,
+  X_INPUT_GAMEPAD_VK_RTHUMB_UPLEFT = 0x5834,
+  X_INPUT_GAMEPAD_VK_RTHUMB_UPRIGHT = 0x5835,
+  X_INPUT_GAMEPAD_VK_RTHUMB_DOWNRIGHT = 0x5836,
+  X_INPUT_GAMEPAD_VK_RTHUMB_DOWNLEFT = 0x5837,
+};
 
 enum X_INPUT_KEYSTROKE_FLAGS {
   X_INPUT_KEYSTROKE_KEYDOWN = 0x0001,
diff --git a/hid/premake5.lua b/hid/premake5.lua
index 1aeef56..749099a 100644
--- a/hid/premake5.lua
+++ b/hid/premake5.lua
@@ -23,6 +23,7 @@ project("xenia-hid-demo")
     "fmt",
     "imgui",
     "xenia-base",
+    "xenia-core",
     "xenia-helper-sdl",
     "xenia-hid",
     "xenia-hid-nop",
diff --git a/hid/sdl/sdl_input_driver.cc b/hid/sdl/sdl_input_driver.cc
index 6b348f2..92bdef7 100644
--- a/hid/sdl/sdl_input_driver.cc
+++ b/hid/sdl/sdl_input_driver.cc
@@ -20,7 +20,6 @@
 #include "xenia/base/logging.h"
 #include "xenia/helper/sdl/sdl_helper.h"
 #include "xenia/hid/hid_flags.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/window.h"
 #include "xenia/ui/windowed_app_context.h"
 
@@ -249,46 +248,48 @@ X_RESULT SDLInputDriver::GetKeystroke(uint32_t users, uint32_t flags,
   // The order of this list is also the order in which events are send if
   // multiple buttons change at once.
   static_assert(sizeof(X_INPUT_GAMEPAD::buttons) == 2);
-  static constexpr std::array<ui::VirtualKey, 34> kVkLookup = {
-      // 00 - True buttons from xinput button field
-      ui::VirtualKey::kXInputPadDpadUp,
-      ui::VirtualKey::kXInputPadDpadDown,
-      ui::VirtualKey::kXInputPadDpadLeft,
-      ui::VirtualKey::kXInputPadDpadRight,
-      ui::VirtualKey::kXInputPadStart,
-      ui::VirtualKey::kXInputPadBack,
-      ui::VirtualKey::kXInputPadLThumbPress,
-      ui::VirtualKey::kXInputPadRThumbPress,
-      ui::VirtualKey::kXInputPadLShoulder,
-      ui::VirtualKey::kXInputPadRShoulder,
-      ui::VirtualKey::kNone, /* Guide has no VK */
-      ui::VirtualKey::kNone, /* Unknown */
-      ui::VirtualKey::kXInputPadA,
-      ui::VirtualKey::kXInputPadB,
-      ui::VirtualKey::kXInputPadX,
-      ui::VirtualKey::kXInputPadY,
-      // 16 - Fake buttons generated from analog inputs
-      ui::VirtualKey::kXInputPadLTrigger,
-      ui::VirtualKey::kXInputPadRTrigger,
-      // 18
-      ui::VirtualKey::kXInputPadLThumbUp,
-      ui::VirtualKey::kXInputPadLThumbDown,
-      ui::VirtualKey::kXInputPadLThumbRight,
-      ui::VirtualKey::kXInputPadLThumbLeft,
-      ui::VirtualKey::kXInputPadLThumbUpLeft,
-      ui::VirtualKey::kXInputPadLThumbUpRight,
-      ui::VirtualKey::kXInputPadLThumbDownRight,
-      ui::VirtualKey::kXInputPadLThumbDownLeft,
-      // 26
-      ui::VirtualKey::kXInputPadRThumbUp,
-      ui::VirtualKey::kXInputPadRThumbDown,
-      ui::VirtualKey::kXInputPadRThumbRight,
-      ui::VirtualKey::kXInputPadRThumbLeft,
-      ui::VirtualKey::kXInputPadRThumbUpLeft,
-      ui::VirtualKey::kXInputPadRThumbUpRight,
-      ui::VirtualKey::kXInputPadRThumbDownRight,
-      ui::VirtualKey::kXInputPadRThumbDownLeft,
-  };
+  static constexpr std::array<std::underlying_type<X_INPUT_GAMEPAD_VK>::type,
+                              34>
+      vk_lookup = {
+          // 00 - True buttons from xinput button field
+          X_INPUT_GAMEPAD_VK_DPAD_UP,
+          X_INPUT_GAMEPAD_VK_DPAD_DOWN,
+          X_INPUT_GAMEPAD_VK_DPAD_LEFT,
+          X_INPUT_GAMEPAD_VK_DPAD_RIGHT,
+          X_INPUT_GAMEPAD_VK_START,
+          X_INPUT_GAMEPAD_VK_BACK,
+          X_INPUT_GAMEPAD_VK_LTHUMB_PRESS,
+          X_INPUT_GAMEPAD_VK_RTHUMB_PRESS,
+          X_INPUT_GAMEPAD_VK_LSHOULDER,
+          X_INPUT_GAMEPAD_VK_RSHOULDER,
+          0, /* Guide has no VK */
+          0, /* Unknown */
+          X_INPUT_GAMEPAD_VK_A,
+          X_INPUT_GAMEPAD_VK_B,
+          X_INPUT_GAMEPAD_VK_X,
+          X_INPUT_GAMEPAD_VK_Y,
+          // 16 - Fake buttons generated from analog inputs
+          X_INPUT_GAMEPAD_VK_LTRIGGER,
+          X_INPUT_GAMEPAD_VK_RTRIGGER,
+          // 18
+          X_INPUT_GAMEPAD_VK_LTHUMB_UP,
+          X_INPUT_GAMEPAD_VK_LTHUMB_DOWN,
+          X_INPUT_GAMEPAD_VK_LTHUMB_RIGHT,
+          X_INPUT_GAMEPAD_VK_LTHUMB_LEFT,
+          X_INPUT_GAMEPAD_VK_LTHUMB_UPLEFT,
+          X_INPUT_GAMEPAD_VK_LTHUMB_UPRIGHT,
+          X_INPUT_GAMEPAD_VK_LTHUMB_DOWNRIGHT,
+          X_INPUT_GAMEPAD_VK_LTHUMB_DOWNLEFT,
+          // 26
+          X_INPUT_GAMEPAD_VK_RTHUMB_UP,
+          X_INPUT_GAMEPAD_VK_RTHUMB_DOWN,
+          X_INPUT_GAMEPAD_VK_RTHUMB_RIGHT,
+          X_INPUT_GAMEPAD_VK_RTHUMB_LEFT,
+          X_INPUT_GAMEPAD_VK_RTHUMB_UPLEFT,
+          X_INPUT_GAMEPAD_VK_RTHUMB_UPRIGHT,
+          X_INPUT_GAMEPAD_VK_RTHUMB_DOWNRIGHT,
+          X_INPUT_GAMEPAD_VK_RTHUMB_DOWNLEFT,
+      };
 
   auto is_active = this->is_active();
 
@@ -328,9 +329,9 @@ X_RESULT SDLInputDriver::GetKeystroke(uint32_t users, uint32_t flags,
     if (last.repeat_state == RepeatState::Repeating &&
         (last.repeat_time + HID_SDL_REPEAT_RATE < guest_now)) {
       last.repeat_time = guest_now;
-      ui::VirtualKey vk = kVkLookup.at(last.repeat_butt_idx);
-      assert_true(vk != ui::VirtualKey::kNone);
-      out_keystroke->virtual_key = uint16_t(vk);
+      auto vk = vk_lookup.at(last.repeat_butt_idx);
+      assert_not_zero(vk);
+      out_keystroke->virtual_key = vk;
       out_keystroke->unicode = 0;
       out_keystroke->user_index = user_index;
       out_keystroke->hid_code = 0;
@@ -349,17 +350,17 @@ X_RESULT SDLInputDriver::GetKeystroke(uint32_t users, uint32_t flags,
     // up before THUMB_LEFT is down.
     for (auto [clear_pass, i] = std::tuple{true, 0}; i < 2;
          clear_pass = false, i++) {
-      for (uint8_t i = 0; i < uint8_t(std::size(kVkLookup)); i++) {
+      for (uint8_t i = 0; i < std::size(vk_lookup); i++) {
         auto fbutton = uint64_t(1) << i;
         if (!(butts_changed & fbutton)) {
           continue;
         }
-        ui::VirtualKey vk = kVkLookup.at(i);
-        if (vk == ui::VirtualKey::kNone) {
+        auto vk = vk_lookup.at(i);
+        if (!vk) {
           continue;
         }
 
-        out_keystroke->virtual_key = uint16_t(vk);
+        out_keystroke->virtual_key = vk;
         out_keystroke->unicode = 0;
         out_keystroke->user_index = user_index;
         out_keystroke->hid_code = 0;
diff --git a/hid/winkey/premake5.lua b/hid/winkey/premake5.lua
index 0e3b865..5f85b7f 100644
--- a/hid/winkey/premake5.lua
+++ b/hid/winkey/premake5.lua
@@ -10,7 +10,8 @@ project("xenia-hid-winkey")
     "xenia-base",
     "xenia-hid",
     "xenia-ui",
+    "xenia-kernel"
   })
   defines({
   })
-  local_platform_files()
+  recursive_platform_files()
diff --git a/hid/winkey/winkey_input_driver.cc b/hid/winkey/winkey_input_driver.cc
index ba0b12c..be0b7a5 100644
--- a/hid/winkey/winkey_input_driver.cc
+++ b/hid/winkey/winkey_input_driver.cc
@@ -12,8 +12,207 @@
 #include "xenia/base/platform_win.h"
 #include "xenia/hid/hid_flags.h"
 #include "xenia/hid/input_system.h"
-#include "xenia/ui/virtual_key.h"
+#include "xenia/kernel/util/shim_utils.h"
 #include "xenia/ui/window.h"
+#include "xenia/ui/window_win.h"
+
+#include "xenia/hid/winkey/hookables/goldeneye.h"
+#include "xenia/hid/winkey/hookables/halo3.h"
+
+DEFINE_bool(invert_y, false, "Invert mouse Y axis", "MouseHook");
+DEFINE_bool(swap_wheel, false,
+            "Swaps binds for wheel, so wheel up will go to next weapon & down "
+            "will go to prev",
+            "MouseHook");
+DEFINE_double(sensitivity, 1, "Mouse sensitivity", "MouseHook");
+DEFINE_bool(disable_autoaim, true,
+            "Disable autoaim in games that support it (currently GE & PD)",
+            "MouseHook");
+
+const uint32_t kTitleIdDefaultBindings = 0;
+
+static const std::unordered_map<std::string, uint32_t> kXInputButtons = {
+    {"up", 0x1},
+    {"down", 0x2},
+    {"left", 0x4},
+    {"right", 0x8},
+
+    {"start", 0x10},
+    {"back", 0x20},
+
+    {"ls", 0x40},
+    {"rs", 0x80},
+
+    {"lb", 0x100},
+    {"rb", 0x200},
+
+    {"a", 0x1000},
+    {"b", 0x2000},
+    {"x", 0x4000},
+    {"y", 0x8000},
+
+    {"lt", XINPUT_BIND_LEFT_TRIGGER},
+    {"rt", XINPUT_BIND_RIGHT_TRIGGER},
+
+    {"ls-up", XINPUT_BIND_LS_UP},
+    {"ls-down", XINPUT_BIND_LS_DOWN},
+    {"ls-left", XINPUT_BIND_LS_LEFT},
+    {"ls-right", XINPUT_BIND_LS_RIGHT},
+
+    {"rs-up", XINPUT_BIND_RS_UP},
+    {"rs-down", XINPUT_BIND_RS_DOWN},
+    {"rs-left", XINPUT_BIND_RS_LEFT},
+    {"rs-right", XINPUT_BIND_RS_RIGHT},
+
+    {"modifier", XINPUT_BIND_MODIFIER}};
+
+static const std::unordered_map<std::string, uint32_t> kKeyMap = {
+    {"lclick", VK_LBUTTON},
+    {"lmouse", VK_LBUTTON},
+    {"mouse1", VK_LBUTTON},
+    {"rclick", VK_RBUTTON},
+    {"rmouse", VK_RBUTTON},
+    {"mouse2", VK_RBUTTON},
+    {"mclick", VK_MBUTTON},
+    {"mmouse", VK_MBUTTON},
+    {"mouse3", VK_MBUTTON},
+    {"mouse4", VK_XBUTTON1},
+    {"mouse5", VK_XBUTTON2},
+    {"mwheelup", VK_BIND_MWHEELUP},
+    {"mwheeldown", VK_BIND_MWHEELDOWN},
+
+    {"control", VK_LCONTROL},
+    {"ctrl", VK_LCONTROL},
+    {"alt", VK_LMENU},
+    {"lcontrol", VK_LCONTROL},
+    {"lctrl", VK_LCONTROL},
+    {"lalt", VK_LMENU},
+    {"rcontrol", VK_RCONTROL},
+    {"rctrl", VK_RCONTROL},
+    {"altgr", VK_RMENU},
+    {"ralt", VK_RMENU},
+
+    {"lshift", VK_LSHIFT},
+    {"shift", VK_LSHIFT},
+    {"rshift", VK_RSHIFT},
+
+    {"backspace", VK_BACK},
+    {"down", VK_DOWN},
+    {"left", VK_LEFT},
+    {"right", VK_RIGHT},
+    {"up", VK_UP},
+    {"delete", VK_DELETE},
+    {"end", VK_END},
+    {"escape", VK_ESCAPE},
+    {"home", VK_HOME},
+    {"pgdown", VK_NEXT},
+    {"pgup", VK_PRIOR},
+    {"return", VK_RETURN},
+    {"enter", VK_RETURN},
+    {"renter", VK_SEPARATOR},
+    {"space", VK_SPACE},
+    {"tab", VK_TAB},
+    {"f1", VK_F1},
+    {"f2", VK_F2},
+    {"f3", VK_F3},
+    {"f4", VK_F4},
+    {"f5", VK_F5},
+    {"f6", VK_F6},
+    {"f7", VK_F7},
+    {"f8", VK_F8},
+    {"f9", VK_F9},
+    {"f10", VK_F10},
+    {"f11", VK_F11},
+    {"f12", VK_F12},
+    {"f13", VK_F13},
+    {"f14", VK_F14},
+    {"f15", VK_F15},
+    {"f16", VK_F16},
+    {"f17", VK_F17},
+    {"f18", VK_F18},
+    {"f19", VK_F19},
+    {"f20", VK_F20},
+    {"num0", VK_NUMPAD0},
+    {"num1", VK_NUMPAD1},
+    {"num2", VK_NUMPAD2},
+    {"num3", VK_NUMPAD3},
+    {"num4", VK_NUMPAD4},
+    {"num5", VK_NUMPAD5},
+    {"num6", VK_NUMPAD6},
+    {"num7", VK_NUMPAD7},
+    {"num8", VK_NUMPAD8},
+    {"num9", VK_NUMPAD9},
+    {"num+", VK_ADD},
+    {"num-", VK_SUBTRACT},
+    {"num*", VK_MULTIPLY},
+    {"num/", VK_DIVIDE},
+    {"num.", VK_DECIMAL},
+    {"numenter", VK_SEPARATOR},
+    {";", VK_OEM_1},
+    {":", VK_OEM_1},
+    {"=", VK_OEM_PLUS},
+    {"+", VK_OEM_PLUS},
+    {",", VK_OEM_COMMA},
+    {"<", VK_OEM_COMMA},
+    {"-", VK_OEM_MINUS},
+    {"_", VK_OEM_MINUS},
+    {".", VK_OEM_PERIOD},
+    {">", VK_OEM_PERIOD},
+    {"/", VK_OEM_2},
+    {"?", VK_OEM_2},
+    {"'", VK_OEM_3},  // uk keyboard
+    {"@", VK_OEM_3},  // uk keyboard
+    {"[", VK_OEM_4},
+    {"{", VK_OEM_4},
+    {"\\", VK_OEM_5},
+    {"|", VK_OEM_5},
+    {"]", VK_OEM_6},
+    {"}", VK_OEM_6},
+    {"#", VK_OEM_7},  // uk keyboard
+    {"\"", VK_OEM_7},
+    {"`", VK_OEM_8},  // uk keyboard, no idea what this is on US..
+};
+
+const std::string WHITESPACE = " \n\r\t\f\v";
+
+std::string ltrim(const std::string& s) {
+  size_t start = s.find_first_not_of(WHITESPACE);
+  return (start == std::string::npos) ? "" : s.substr(start);
+}
+
+std::string rtrim(const std::string& s) {
+  size_t end = s.find_last_not_of(WHITESPACE);
+  return (end == std::string::npos) ? "" : s.substr(0, end + 1);
+}
+
+std::string trim(const std::string& s) { return rtrim(ltrim(s)); }
+
+int ParseButtonCombination(const char* combo) {
+  size_t len = strlen(combo);
+
+  int retval = 0;
+  std::string cur_token;
+
+  // Parse combo tokens into buttons bitfield (tokens seperated by any
+  // non-alphabetical char, eg. +)
+  for (size_t i = 0; i < len; i++) {
+    char c = combo[i];
+
+    if (!isalpha(c) && c != '-') {
+      if (cur_token.length() && kXInputButtons.count(cur_token))
+        retval |= kXInputButtons.at(cur_token);
+
+      cur_token.clear();
+      continue;
+    }
+    cur_token += ::tolower(c);
+  }
+
+  if (cur_token.length() && kXInputButtons.count(cur_token))
+    retval |= kXInputButtons.at(cur_token);
+
+  return retval;
+}
 
 namespace xe {
 namespace hid {
@@ -21,7 +220,149 @@ namespace winkey {
 
 WinKeyInputDriver::WinKeyInputDriver(xe::ui::Window* window)
     : InputDriver(window), packet_number_(1) {
-  // Register a key listener.
+  memset(key_states_, 0, 256);
+
+  // Register our supported hookable games
+  hookable_games_.push_back(std::move(std::make_unique<GoldeneyeGame>()));
+  hookable_games_.push_back(std::move(std::make_unique<Halo3Game>()));
+
+  // Read bindings file if it exists
+  std::ifstream binds("bindings.ini");
+  if (!binds.is_open()) {
+    MessageBox(((xe::ui::Win32Window*)window)->hwnd(),
+               L"Xenia failed to load bindings.ini file, MouseHook won't have "
+               "any keys bound!",
+               L"Xenia", MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
+  } else {
+    std::string cur_section = "default";
+    uint32_t cur_game = kTitleIdDefaultBindings;
+    std::unordered_map<uint32_t, uint32_t> cur_binds;
+
+    std::string line;
+    while (std::getline(binds, line)) {
+      line = trim(line);
+      if (!line.length()) {
+        continue; // blank line
+      }
+      if (line[0] == ';') {
+        continue; // comment
+      }
+
+      if (line.length() >= 3 && line[0] == '[' &&
+          line[line.length() - 1] == ']') {
+
+        // New section
+        if (cur_binds.size() > 0) {
+          key_binds_.emplace(cur_game, cur_binds);
+          cur_binds.clear();
+        }
+        cur_section = line.substr(1, line.length() - 2);
+        auto sep = cur_section.find_first_of(' ');
+        if (sep >= 0) {
+          cur_section = cur_section.substr(0, sep);
+        }
+        cur_game = std::stoul(cur_section, nullptr, 16);
+
+        continue;
+      }
+
+      // Not a section, must be bind
+      auto sep = line.find_last_of('=');
+      if (sep < 0) {
+        continue;  // invalid
+      }
+
+      auto key_str = trim(line.substr(0, sep));
+      auto val_str = trim(line.substr(sep + 1));
+
+      // key tolower
+      std::transform(key_str.begin(), key_str.end(), key_str.begin(),
+                     [](unsigned char c) { return std::tolower(c); });
+
+      // Parse key
+      uint32_t key = 0;
+      if (kKeyMap.count(key_str)) {
+        key = kKeyMap.at(key_str);
+      } else {
+        if (key_str.length() == 1 &&
+            (isalpha(key_str[0]) || isdigit(key_str[0]))) {
+          key = (unsigned char)toupper(key_str[0]);
+        }
+      }
+
+      if (!key) {
+        continue;  // unknown key
+      }
+
+      // Parse value
+      uint32_t value = ParseButtonCombination(val_str.c_str());
+      cur_binds.emplace(key, value);
+    }
+    if (cur_binds.size() > 0) {
+      key_binds_.emplace(cur_game, cur_binds);
+      cur_binds.clear();
+    }
+  }
+
+  // Register our event listeners
+  window->on_raw_mouse.AddListener([this](ui::MouseEvent* evt) {
+    if (!is_active()) {
+      return;
+    }
+
+    std::unique_lock<std::mutex> mouse_lock(mouse_mutex_);
+
+    MouseEvent mouse;
+    mouse.x_delta = evt->x();
+    mouse.y_delta = evt->y();
+    mouse.buttons = evt->dx();
+    mouse.wheel_delta = evt->dy();
+    mouse_events_.push(mouse);
+
+    {
+      std::unique_lock<std::mutex> key_lock(key_mutex_);
+      if (mouse.buttons & RI_MOUSE_LEFT_BUTTON_DOWN) {
+        key_states_[VK_LBUTTON] = true;
+      }
+      if (mouse.buttons & RI_MOUSE_LEFT_BUTTON_UP) {
+        key_states_[VK_LBUTTON] = false;
+      }
+      if (mouse.buttons & RI_MOUSE_RIGHT_BUTTON_DOWN) {
+        key_states_[VK_RBUTTON] = true;
+      }
+      if (mouse.buttons & RI_MOUSE_RIGHT_BUTTON_UP) {
+        key_states_[VK_RBUTTON] = false;
+      }
+      if (mouse.buttons & RI_MOUSE_MIDDLE_BUTTON_DOWN) {
+        key_states_[VK_MBUTTON] = true;
+      }
+      if (mouse.buttons & RI_MOUSE_MIDDLE_BUTTON_UP) {
+        key_states_[VK_MBUTTON] = false;
+      }
+      if (mouse.buttons & RI_MOUSE_BUTTON_4_DOWN) {
+        key_states_[VK_XBUTTON1] = true;
+      }
+      if (mouse.buttons & RI_MOUSE_BUTTON_4_UP) {
+        key_states_[VK_XBUTTON1] = false;
+      }
+      if (mouse.buttons & RI_MOUSE_BUTTON_5_DOWN) {
+        key_states_[VK_XBUTTON2] = true;
+      }
+      if (mouse.buttons & RI_MOUSE_BUTTON_5_UP) {
+        key_states_[VK_XBUTTON2] = false;
+      }
+    }
+  });
+
+  window->on_raw_keyboard.AddListener([this, window](ui::KeyEvent* evt) {
+    if (!is_active()) {
+      return;
+    }
+
+    std::unique_lock<std::mutex> key_lock(key_mutex_);
+    key_states_[evt->key_code() & 0xFF] = evt->prev_state();
+  });
+
   window->on_key_down.AddListener([this](ui::KeyEvent* evt) {
     if (!is_active()) {
       return;
@@ -30,7 +371,7 @@ WinKeyInputDriver::WinKeyInputDriver(xe::ui::Window* window)
     auto global_lock = global_critical_region_.Acquire();
 
     KeyEvent key;
-    key.virtual_key = evt->virtual_key();
+    key.vkey = evt->key_code();
     key.transition = true;
     key.prev_state = evt->prev_state();
     key.repeat_count = evt->repeat_count();
@@ -44,7 +385,7 @@ WinKeyInputDriver::WinKeyInputDriver(xe::ui::Window* window)
     auto global_lock = global_critical_region_.Acquire();
 
     KeyEvent key;
-    key.virtual_key = evt->virtual_key();
+    key.vkey = evt->key_code();
     key.transition = false;
     key.prev_state = evt->prev_state();
     key.repeat_count = evt->repeat_count();
@@ -78,8 +419,7 @@ X_RESULT WinKeyInputDriver::GetCapabilities(uint32_t user_index, uint32_t flags,
   return X_ERROR_SUCCESS;
 }
 
-#define IS_KEY_TOGGLED(key) ((GetKeyState(key) & 0x1) == 0x1)
-#define IS_KEY_DOWN(key) ((GetAsyncKeyState(key) & 0x8000) == 0x8000)
+#define IS_KEY_DOWN(key) (key_states_[key])
 
 X_RESULT WinKeyInputDriver::GetState(uint32_t user_index,
                                      X_INPUT_STATE* out_state) {
@@ -96,116 +436,103 @@ X_RESULT WinKeyInputDriver::GetState(uint32_t user_index,
   int16_t thumb_ly = 0;
   int16_t thumb_rx = 0;
   int16_t thumb_ry = 0;
+  bool modifier_pressed = false;
 
-  if (window()->has_focus() && is_active()) {
-    if (IS_KEY_TOGGLED(VK_CAPITAL) || IS_KEY_DOWN(VK_SHIFT)) {
-      // dpad toggled
-      if (IS_KEY_DOWN('A')) {
-        // A
-        buttons |= 0x0004;  // XINPUT_GAMEPAD_DPAD_LEFT
-      }
-      if (IS_KEY_DOWN('D')) {
-        // D
-        buttons |= 0x0008;  // XINPUT_GAMEPAD_DPAD_RIGHT
-      }
-      if (IS_KEY_DOWN('S')) {
-        // S
-        buttons |= 0x0002;  // XINPUT_GAMEPAD_DPAD_DOWN
-      }
-      if (IS_KEY_DOWN('W')) {
-        // W
-        buttons |= 0x0001;  // XINPUT_GAMEPAD_DPAD_UP
-      }
-    } else {
-      // left stick
-      if (IS_KEY_DOWN('A')) {
-        // A
-        thumb_lx += SHRT_MIN;
-      }
-      if (IS_KEY_DOWN('D')) {
-        // D
-        thumb_lx += SHRT_MAX;
-      }
-      if (IS_KEY_DOWN('S')) {
-        // S
-        thumb_ly += SHRT_MIN;
-      }
-      if (IS_KEY_DOWN('W')) {
-        // W
-        thumb_ly += SHRT_MAX;
-      }
-    }
-
-    if (IS_KEY_DOWN('F')) {
-      // F
-      buttons |= 0x0040;  // XINPUT_GAMEPAD_LEFT_THUMB
-    }
+  X_RESULT result = X_ERROR_SUCCESS;
 
-    // Right stick
-    if (IS_KEY_DOWN(VK_UP)) {
-      // Up
-      thumb_ry += SHRT_MAX;
-    }
-    if (IS_KEY_DOWN(VK_DOWN)) {
-      // Down
-      thumb_ry += SHRT_MIN;
-    }
-    if (IS_KEY_DOWN(VK_RIGHT)) {
-      // Right
-      thumb_rx += SHRT_MAX;
-    }
-    if (IS_KEY_DOWN(VK_LEFT)) {
-      // Left
-      thumb_rx += SHRT_MIN;
-    }
+  RawInputState state;
 
-    if (IS_KEY_DOWN('L')) {
-      // L
-      buttons |= 0x4000;  // XINPUT_GAMEPAD_X
-    }
-    if (IS_KEY_DOWN(VK_OEM_7)) {
-      // '
-      buttons |= 0x2000;  // XINPUT_GAMEPAD_B
-    }
-    if (IS_KEY_DOWN(VK_OEM_1)) {
-      // ;
-      buttons |= 0x1000;  // XINPUT_GAMEPAD_A
-    }
-    if (IS_KEY_DOWN('P')) {
-      // P
-      buttons |= 0x8000;  // XINPUT_GAMEPAD_Y
+  if (window()->has_focus() && is_active()) {
+    {
+      std::unique_lock<std::mutex> mouse_lock(mouse_mutex_);
+      while (!mouse_events_.empty()) {
+        auto& mouse = mouse_events_.front();
+        state.mouse.x_delta += mouse.x_delta;
+        state.mouse.y_delta += mouse.y_delta;
+        state.mouse.wheel_delta += mouse.wheel_delta;
+        mouse_events_.pop();
+      }
     }
 
-    if (IS_KEY_DOWN('K')) {
-      // K
-      buttons |= 0x0080;  // XINPUT_GAMEPAD_RIGHT_THUMB
+    if (state.mouse.wheel_delta != 0) {
+      if (cvars::swap_wheel) {
+        state.mouse.wheel_delta = -state.mouse.wheel_delta;
+      }
     }
 
-    if (IS_KEY_DOWN('Q') || IS_KEY_DOWN('I')) {
-      // Q / I
-      left_trigger = 0xFF;
-    }
+    {
+      std::unique_lock<std::mutex> key_lock(key_mutex_);
+      state.key_states = key_states_;
 
-    if (IS_KEY_DOWN('E') || IS_KEY_DOWN('O')) {
-      // E / O
-      right_trigger = 0xFF;
-    }
+      // Handle key bindings
+      uint32_t cur_game = xe::kernel::kernel_state()->title_id();
+      if (!key_binds_.count(cur_game)) {
+        cur_game = kTitleIdDefaultBindings;
+      }
+      if (key_binds_.count(cur_game)) {
+        auto& binds = key_binds_.at(cur_game);
+        auto process_binding = [binds, &buttons, &left_trigger, &right_trigger,
+                                &thumb_lx, &thumb_ly, &thumb_rx, &thumb_ry,
+                                &modifier_pressed](uint32_t key) {
+          if (!binds.count(key)) {
+            return;
+          }
+          auto binding = binds.at(key);
+          buttons |= (binding & XINPUT_BUTTONS_MASK);
+
+          if (binding & XINPUT_BIND_LEFT_TRIGGER) {
+            left_trigger = 0xFF;
+          }
+
+          if (binding & XINPUT_BIND_RIGHT_TRIGGER) {
+            right_trigger = 0xFF;
+          }
+
+          if (binding & XINPUT_BIND_LS_UP) {
+            thumb_ly = SHRT_MAX;
+          }
+          if (binding & XINPUT_BIND_LS_DOWN) {
+            thumb_ly = SHRT_MIN;
+          }
+          if (binding & XINPUT_BIND_LS_LEFT) {
+            thumb_lx = SHRT_MIN;
+          }
+          if (binding & XINPUT_BIND_LS_RIGHT) {
+            thumb_lx = SHRT_MAX;
+          }
+
+          if (binding & XINPUT_BIND_RS_UP) {
+            thumb_ry = SHRT_MAX;
+          }
+          if (binding & XINPUT_BIND_RS_DOWN) {
+            thumb_ry = SHRT_MIN;
+          }
+          if (binding & XINPUT_BIND_RS_LEFT) {
+            thumb_rx = SHRT_MIN;
+          }
+          if (binding & XINPUT_BIND_RS_RIGHT) {
+            thumb_rx = SHRT_MAX;
+          }
+
+          if (binding & XINPUT_BIND_MODIFIER) {
+            modifier_pressed = true;
+          }
+        };
+
+        if (state.mouse.wheel_delta != 0) {
+          if (state.mouse.wheel_delta > 0) {
+            process_binding(VK_BIND_MWHEELUP);
+          } else {
+            process_binding(VK_BIND_MWHEELDOWN);
+          }
+        }
 
-    if (IS_KEY_DOWN('Z')) {
-      // Z
-      buttons |= 0x0020;  // XINPUT_GAMEPAD_BACK
-    }
-    if (IS_KEY_DOWN('X')) {
-      // X
-      buttons |= 0x0010;  // XINPUT_GAMEPAD_START
-    }
-    if (IS_KEY_DOWN('1')) {
-      // 1
-      buttons |= 0x0100;  // XINPUT_GAMEPAD_LEFT_SHOULDER
-    }
-    if (IS_KEY_DOWN('3')) {
-      // 3
-      buttons |= 0x0200;  // XINPUT_GAMEPAD_RIGHT_SHOULDER
+        for (int i = 0; i < 0x100; i++) {
+          if (key_states_[i]) {
+            process_binding(i);
+          }
+        }
+      }
     }
   }
 
@@ -218,7 +545,29 @@ X_RESULT WinKeyInputDriver::GetState(uint32_t user_index,
   out_state->gamepad.thumb_rx = thumb_rx;
   out_state->gamepad.thumb_ry = thumb_ry;
 
-  return X_ERROR_SUCCESS;
+  // Check if we have any hooks/injections for the current game
+  bool game_modifier_handled = false;
+  for (auto& game : hookable_games_) {
+    if (game->IsGameSupported()) {
+      std::unique_lock<std::mutex> key_lock(key_mutex_);
+      game->DoHooks(user_index, state, out_state);
+      if (modifier_pressed) {
+        game_modifier_handled =
+            game->ModifierKeyHandler(user_index, state, out_state);
+      }
+      break;
+    }
+  }
+
+  if (!game_modifier_handled && modifier_pressed) {
+    // Modifier not handled by any supported game class, apply default modifier
+    // (swap LS input to RS, for games that require RS movement)
+    out_state->gamepad.thumb_rx = out_state->gamepad.thumb_lx;
+    out_state->gamepad.thumb_ry = out_state->gamepad.thumb_ly;
+    out_state->gamepad.thumb_lx = out_state->gamepad.thumb_ly = 0;
+  }
+
+  return result;
 }
 
 X_RESULT WinKeyInputDriver::SetState(uint32_t user_index,
@@ -242,7 +591,7 @@ X_RESULT WinKeyInputDriver::GetKeystroke(uint32_t user_index, uint32_t flags,
 
   X_RESULT result = X_ERROR_EMPTY;
 
-  ui::VirtualKey xinput_virtual_key = ui::VirtualKey::kNone;
+  uint16_t virtual_key = 0;
   uint16_t unicode = 0;
   uint16_t keystroke_flags = 0;
   uint8_t hid_code = 0;
@@ -259,93 +608,82 @@ X_RESULT WinKeyInputDriver::GetKeystroke(uint32_t user_index, uint32_t flags,
     key_events_.pop();
   }
 
-  switch (evt.virtual_key) {
-    case ui::VirtualKey::kOem1:  // ;
-      xinput_virtual_key = ui::VirtualKey::kXInputPadA;
-      break;
-    case ui::VirtualKey::kOem7:  // '
-      xinput_virtual_key = ui::VirtualKey::kXInputPadB;
-      break;
-    case ui::VirtualKey::kL:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadX;
-      break;
-    case ui::VirtualKey::kP:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadY;
-      break;
-    case ui::VirtualKey::k3:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRShoulder;
-      break;
-    case ui::VirtualKey::k1:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadLShoulder;
-      break;
-    case ui::VirtualKey::kQ:
-    case ui::VirtualKey::kI:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadLTrigger;
-      break;
-    case ui::VirtualKey::kE:
-    case ui::VirtualKey::kO:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRTrigger;
-      break;
-    case ui::VirtualKey::kX:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadStart;
-      break;
-    case ui::VirtualKey::kZ:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadBack;
-      break;
-    case ui::VirtualKey::kUp:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRThumbUp;
-      break;
-    case ui::VirtualKey::kDown:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRThumbDown;
-      break;
-    case ui::VirtualKey::kRight:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRThumbRight;
-      break;
-    case ui::VirtualKey::kLeft:
-      xinput_virtual_key = ui::VirtualKey::kXInputPadRThumbLeft;
-      break;
-    default:
-      // TODO(DrChat): Some other way to toggle this...
-      if (IS_KEY_TOGGLED(VK_CAPITAL) || IS_KEY_DOWN(VK_SHIFT)) {
-        // D-pad toggled.
-        switch (evt.virtual_key) {
-          case ui::VirtualKey::kW:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadDpadUp;
-            break;
-          case ui::VirtualKey::kS:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadDpadDown;
-            break;
-          case ui::VirtualKey::kA:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadDpadLeft;
-            break;
-          case ui::VirtualKey::kD:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadDpadRight;
-            break;
-          default:
-            break;
-        }
-      } else {
-        // Left thumbstick.
-        switch (evt.virtual_key) {
-          case ui::VirtualKey::kW:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadLThumbUp;
-            break;
-          case ui::VirtualKey::kS:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadLThumbDown;
-            break;
-          case ui::VirtualKey::kA:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadLThumbLeft;
-            break;
-          case ui::VirtualKey::kD:
-            xinput_virtual_key = ui::VirtualKey::kXInputPadLThumbRight;
-            break;
-          default:
-            break;
-        }
-      }
+  // left stick
+  if (evt.vkey == (0x57)) {
+    // W
+    virtual_key = 0x5820;  // VK_PAD_LTHUMB_UP
+  }
+  if (evt.vkey == (0x53)) {
+    // S
+    virtual_key = 0x5821;  // VK_PAD_LTHUMB_DOWN
+  }
+  if (evt.vkey == (0x44)) {
+    // D
+    virtual_key = 0x5822;  // VK_PAD_LTHUMB_RIGHT
+  }
+  if (evt.vkey == (0x41)) {
+    // A
+    virtual_key = 0x5823;  // VK_PAD_LTHUMB_LEFT
+  }
+
+  // Right stick
+  if (evt.vkey == (0x26)) {
+    // Up
+    virtual_key = 0x5830;
+  }
+  if (evt.vkey == (0x28)) {
+    // Down
+    virtual_key = 0x5831;
+  }
+  if (evt.vkey == (0x27)) {
+    // Right
+    virtual_key = 0x5832;
+  }
+  if (evt.vkey == (0x25)) {
+    // Left
+    virtual_key = 0x5833;
+  }
+
+  if (evt.vkey == (0x4C)) {
+    // L
+    virtual_key = 0x5802;  // VK_PAD_X
+  } else if (evt.vkey == (VK_OEM_7)) {
+    // '
+    virtual_key = 0x5801;  // VK_PAD_B
+  } else if (evt.vkey == (VK_OEM_1)) {
+    // ;
+    virtual_key = 0x5800;  // VK_PAD_A
+  } else if (evt.vkey == (0x50)) {
+    // P
+    virtual_key = 0x5803;  // VK_PAD_Y
+  }
+
+  if (evt.vkey == (0x58)) {
+    // X
+    virtual_key = 0x5814;  // VK_PAD_START
+  }
+  if (evt.vkey == (0x5A)) {
+    // Z
+    virtual_key = 0x5815;  // VK_PAD_BACK
+  }
+  if (evt.vkey == (0x51) || evt.vkey == (0x49)) {
+    // Q / I
+    virtual_key = 0x5806;  // VK_PAD_LTRIGGER
+  }
+  if (evt.vkey == (0x45) || evt.vkey == (0x4F)) {
+    // E / O
+    virtual_key = 0x5807;  // VK_PAD_RTRIGGER
+  }
+  if (evt.vkey == (0x31)) {
+    // 1
+    virtual_key = 0x5805;  // VK_PAD_LSHOULDER
+  }
+  if (evt.vkey == (0x33)) {
+    // 3
+    virtual_key = 0x5804;  // VK_PAD_RSHOULDER
   }
 
-  if (xinput_virtual_key != ui::VirtualKey::kNone) {
+  if (virtual_key != 0) {
     if (evt.transition == true) {
       keystroke_flags |= 0x0001;  // XINPUT_KEYSTROKE_KEYDOWN
     } else if (evt.transition == false) {
@@ -359,7 +697,7 @@ X_RESULT WinKeyInputDriver::GetKeystroke(uint32_t user_index, uint32_t flags,
     result = X_ERROR_SUCCESS;
   }
 
-  out_keystroke->virtual_key = uint16_t(xinput_virtual_key);
+  out_keystroke->virtual_key = virtual_key;
   out_keystroke->unicode = unicode;
   out_keystroke->flags = keystroke_flags;
   out_keystroke->user_index = 0;
diff --git a/hid/winkey/winkey_input_driver.h b/hid/winkey/winkey_input_driver.h
index f015b74..394af54 100644
--- a/hid/winkey/winkey_input_driver.h
+++ b/hid/winkey/winkey_input_driver.h
@@ -14,7 +14,26 @@
 
 #include "xenia/base/mutex.h"
 #include "xenia/hid/input_driver.h"
-#include "xenia/ui/virtual_key.h"
+#include "xenia/hid/winkey/hookables/hookable_game.h"
+
+#define XINPUT_BUTTONS_MASK 0xFFFF
+#define XINPUT_BIND_LEFT_TRIGGER (1 << 16)
+#define XINPUT_BIND_RIGHT_TRIGGER (1 << 17)
+
+#define XINPUT_BIND_LS_UP (1 << 18)
+#define XINPUT_BIND_LS_DOWN (1 << 19)
+#define XINPUT_BIND_LS_LEFT (1 << 20)
+#define XINPUT_BIND_LS_RIGHT (1 << 21)
+
+#define XINPUT_BIND_RS_UP (1 << 22)
+#define XINPUT_BIND_RS_DOWN (1 << 23)
+#define XINPUT_BIND_RS_LEFT (1 << 24)
+#define XINPUT_BIND_RS_RIGHT (1 << 25)
+
+#define XINPUT_BIND_MODIFIER (1 << 26)
+
+#define VK_BIND_MWHEELUP 0x10000
+#define VK_BIND_MWHEELDOWN 0x20000
 
 namespace xe {
 namespace hid {
@@ -36,7 +55,7 @@ class WinKeyInputDriver : public InputDriver {
 
  protected:
   struct KeyEvent {
-    ui::VirtualKey virtual_key = ui::VirtualKey::kNone;
+    int vkey = 0;
     int repeat_count = 0;
     bool transition = false;  // going up(false) or going down(true)
     bool prev_state = false;  // down(true) or up(false)
@@ -45,7 +64,18 @@ class WinKeyInputDriver : public InputDriver {
   xe::global_critical_region global_critical_region_;
   std::queue<KeyEvent> key_events_;
 
+  std::mutex mouse_mutex_;
+  std::queue<MouseEvent> mouse_events_;
+
+  std::mutex key_mutex_;
+  bool key_states_[256];
+
   uint32_t packet_number_;
+
+  std::vector<std::unique_ptr<HookableGame>> hookable_games_;
+
+  std::unordered_map<uint32_t, std::unordered_map<uint32_t, uint32_t>>
+      key_binds_;
 };
 
 }  // namespace winkey
diff --git a/kernel/util/shim_utils.h b/kernel/util/shim_utils.h
index 964845b..bf811df 100644
--- a/kernel/util/shim_utils.h
+++ b/kernel/util/shim_utils.h
@@ -452,8 +452,8 @@ inline void AppendParam(StringBuffer* string_buffer,
 }
 inline void AppendParam(StringBuffer* string_buffer,
                         pointer_t<X_EXCEPTION_RECORD> record) {
-  string_buffer->AppendFormat("{:08X}({:08X})", record.guest_address(),
-                              uint32_t(record->exception_code));
+  //string_buffer->AppendFormat("{:08X}({:08X})", record.guest_address(),
+    //                          uint32_t(record->exception_code));
 }
 template <typename T>
 void AppendParam(StringBuffer* string_buffer, pointer_t<T> param) {
diff --git a/kernel/xam/xam_ui.cc b/kernel/xam/xam_ui.cc
index 21b0590..edaee06 100644
--- a/kernel/xam/xam_ui.cc
+++ b/kernel/xam/xam_ui.cc
@@ -283,11 +283,17 @@ dword_result_t XamShowMessageBoxUI(dword_t user_index, lpu16string_t title_ptr,
     buttons.push_back(xe::to_utf8(button));
   }
 
+  auto title_id = kernel_state()->title_id();
+
   X_RESULT result;
-  if (cvars::headless) {
+  if (cvars::headless || title_id == 0x584109C2) {
+    uint32_t active_btn = active_button;
+    if (title_id == 0x584109C2 && active_btn == 0) {
+      active_btn = 1;
+    }
     // Auto-pick the focused button.
-    auto run = [result_ptr, active_button]() -> X_RESULT {
-      *result_ptr = static_cast<uint32_t>(active_button);
+    auto run = [result_ptr, active_btn]() -> X_RESULT {
+      *result_ptr = static_cast<uint32_t>(active_btn);
       return X_ERROR_SUCCESS;
     };
     result = xeXamDispatchHeadless(run, overlapped);
diff --git a/kernel/xbdm/xbdm_misc.cc b/kernel/xbdm/xbdm_misc.cc
index e15af9e..3256d93 100644
--- a/kernel/xbdm/xbdm_misc.cc
+++ b/kernel/xbdm/xbdm_misc.cc
@@ -12,8 +12,12 @@
 #include "xenia/kernel/util/shim_utils.h"
 #include "xenia/kernel/xbdm/xbdm_private.h"
 #include "xenia/kernel/xthread.h"
+#include "xenia/vfs/devices/host_path_device.h"
+#include "xenia/emulator.h"
 #include "xenia/xbox.h"
 
+DEFINE_string(devkit_root, "", "Root path for devkit: partition", "Storage");
+
 namespace xe {
 namespace kernel {
 namespace xbdm {
@@ -75,7 +79,34 @@ dword_result_t DmWalkLoadedModules(lpdword_t unk0_ptr, lpdword_t unk1_ptr) {
 }
 DECLARE_XBDM_EXPORT1(DmWalkLoadedModules, kDebug, kStub);
 
-void DmMapDevkitDrive() {}
+dword_result_t DmMapDevkitDrive() {
+  auto* emulator = kernel_state()->emulator();
+  auto* file_system = emulator->file_system();
+  std::string existing;
+
+  if (file_system->FindSymbolicLink("devkit:", existing)) {
+    return X_STATUS_SUCCESS;  // TODO: check what actual code returned is
+  }
+
+  auto path = emulator->executable_path().parent_path();
+  if (!cvars::devkit_root.empty()) {
+    path = cvars::devkit_root;
+  }
+
+  auto device =
+      std::make_unique<xe::vfs::HostPathDevice>("\\devkit", path, false);
+  if (!device->Initialize()) {
+    XELOGE("DmMapDevkitDrive: Unable to scan devkit path");
+  } else {
+    if (!file_system->RegisterDevice(std::move(device))) {
+      XELOGE("DmMapDevkitDrive: Unable to register devkit path");
+    } else {
+      file_system->RegisterSymbolicLink("devkit:", "\\devkit");
+    }
+  }
+
+  return X_STATUS_SUCCESS;
+}
 DECLARE_XBDM_EXPORT1(DmMapDevkitDrive, kDebug, kStub);
 
 dword_result_t DmFindPdbSignature(lpdword_t unk0_ptr, lpdword_t unk1_ptr) {
diff --git a/ui/imgui_drawer.cc b/ui/imgui_drawer.cc
index 276cea1..158c924 100644
--- a/ui/imgui_drawer.cc
+++ b/ui/imgui_drawer.cc
@@ -12,7 +12,6 @@
 #include "third_party/imgui/imgui.h"
 #include "xenia/base/assert.h"
 #include "xenia/base/logging.h"
-#include "xenia/base/math.h"
 #include "xenia/ui/window.h"
 
 namespace xe {
@@ -108,23 +107,23 @@ void ImGuiDrawer::Initialize() {
   style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.00f, 1.00f, 0.00f, 0.21f);
   style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
 
-  io.KeyMap[ImGuiKey_Tab] = int(ui::VirtualKey::kTab);
-  io.KeyMap[ImGuiKey_LeftArrow] = int(ui::VirtualKey::kLeft);
-  io.KeyMap[ImGuiKey_RightArrow] = int(ui::VirtualKey::kRight);
-  io.KeyMap[ImGuiKey_UpArrow] = int(ui::VirtualKey::kUp);
-  io.KeyMap[ImGuiKey_DownArrow] = int(ui::VirtualKey::kDown);
-  io.KeyMap[ImGuiKey_Home] = int(ui::VirtualKey::kHome);
-  io.KeyMap[ImGuiKey_End] = int(ui::VirtualKey::kEnd);
-  io.KeyMap[ImGuiKey_Delete] = int(ui::VirtualKey::kDelete);
-  io.KeyMap[ImGuiKey_Backspace] = int(ui::VirtualKey::kBack);
-  io.KeyMap[ImGuiKey_Enter] = int(ui::VirtualKey::kReturn);
-  io.KeyMap[ImGuiKey_Escape] = int(ui::VirtualKey::kEscape);
-  io.KeyMap[ImGuiKey_A] = int(ui::VirtualKey::kA);
-  io.KeyMap[ImGuiKey_C] = int(ui::VirtualKey::kC);
-  io.KeyMap[ImGuiKey_V] = int(ui::VirtualKey::kV);
-  io.KeyMap[ImGuiKey_X] = int(ui::VirtualKey::kX);
-  io.KeyMap[ImGuiKey_Y] = int(ui::VirtualKey::kY);
-  io.KeyMap[ImGuiKey_Z] = int(ui::VirtualKey::kZ);
+  io.KeyMap[ImGuiKey_Tab] = 0x09;  // VK_TAB;
+  io.KeyMap[ImGuiKey_LeftArrow] = 0x25;
+  io.KeyMap[ImGuiKey_RightArrow] = 0x27;
+  io.KeyMap[ImGuiKey_UpArrow] = 0x26;
+  io.KeyMap[ImGuiKey_DownArrow] = 0x28;
+  io.KeyMap[ImGuiKey_Home] = 0x24;
+  io.KeyMap[ImGuiKey_End] = 0x23;
+  io.KeyMap[ImGuiKey_Delete] = 0x2E;
+  io.KeyMap[ImGuiKey_Backspace] = 0x08;
+  io.KeyMap[ImGuiKey_Enter] = 0x0D;
+  io.KeyMap[ImGuiKey_Escape] = 0x1B;
+  io.KeyMap[ImGuiKey_A] = 'A';
+  io.KeyMap[ImGuiKey_C] = 'C';
+  io.KeyMap[ImGuiKey_V] = 'V';
+  io.KeyMap[ImGuiKey_X] = 'X';
+  io.KeyMap[ImGuiKey_Y] = 'Y';
+  io.KeyMap[ImGuiKey_Z] = 'Z';
 }
 
 void ImGuiDrawer::SetupFont() {
@@ -229,16 +228,36 @@ void ImGuiDrawer::RenderDrawLists() {
   }
 }
 
-void ImGuiDrawer::OnKeyDown(KeyEvent* e) { OnKey(e, true); }
+void ImGuiDrawer::OnKeyDown(KeyEvent* e) {
+  auto& io = GetIO();
+  io.KeysDown[e->key_code()] = true;
+  switch (e->key_code()) {
+    case 16: {
+      io.KeyShift = true;
+    } break;
+    case 17: {
+      io.KeyCtrl = true;
+    } break;
+  }
+}
 
-void ImGuiDrawer::OnKeyUp(KeyEvent* e) { OnKey(e, false); }
+void ImGuiDrawer::OnKeyUp(KeyEvent* e) {
+  auto& io = GetIO();
+  io.KeysDown[e->key_code()] = false;
+  switch (e->key_code()) {
+    case 16: {
+      io.KeyShift = false;
+    } break;
+    case 17: {
+      io.KeyCtrl = false;
+    } break;
+  }
+}
 
 void ImGuiDrawer::OnKeyChar(KeyEvent* e) {
   auto& io = GetIO();
-  // TODO(Triang3l): Accept the Unicode character.
-  unsigned int character = static_cast<unsigned int>(e->virtual_key());
-  if (character > 0 && character < 0x10000) {
-    io.AddInputCharacter(character);
+  if (e->key_code() > 0 && e->key_code() < 0x10000) {
+    io.AddInputCharacter(e->key_code());
     e->set_handled(true);
   }
 }
@@ -308,30 +327,5 @@ void ImGuiDrawer::OnMouseWheel(MouseEvent* e) {
   io.MouseWheel += float(e->dy() / 120.0f);
 }
 
-void ImGuiDrawer::OnKey(KeyEvent* e, bool is_down) {
-  auto& io = GetIO();
-  VirtualKey virtual_key = e->virtual_key();
-  if (size_t(virtual_key) < xe::countof(io.KeysDown)) {
-    io.KeysDown[size_t(virtual_key)] = is_down;
-  }
-  switch (virtual_key) {
-    case VirtualKey::kShift:
-      io.KeyShift = is_down;
-      break;
-    case VirtualKey::kControl:
-      io.KeyCtrl = is_down;
-      break;
-    case VirtualKey::kMenu:
-      // FIXME(Triang3l): Doesn't work in xenia-ui-window-demo.
-      io.KeyAlt = is_down;
-      break;
-    case VirtualKey::kLWin:
-      io.KeySuper = is_down;
-      break;
-    default:
-      break;
-  }
-}
-
 }  // namespace ui
 }  // namespace xe
diff --git a/ui/imgui_drawer.h b/ui/imgui_drawer.h
index 2c370b2..f9b0ecf 100644
--- a/ui/imgui_drawer.h
+++ b/ui/imgui_drawer.h
@@ -58,8 +58,6 @@ class ImGuiDrawer : public WindowListener {
   ImGuiContext* internal_state_ = nullptr;
   std::unique_ptr<ImmediateTexture> font_texture_;
 
- private:
-  void OnKey(KeyEvent* e, bool is_down);
 };
 
 }  // namespace ui
diff --git a/ui/ui_event.h b/ui/ui_event.h
index 993eda6..9fd4734 100644
--- a/ui/ui_event.h
+++ b/ui/ui_event.h
@@ -12,8 +12,6 @@
 
 #include <filesystem>
 
-#include "xenia/ui/virtual_key.h"
-
 namespace xe {
 namespace ui {
 
@@ -44,12 +42,11 @@ class FileDropEvent : public UIEvent {
 
 class KeyEvent : public UIEvent {
  public:
-  KeyEvent(Window* target, VirtualKey virtual_key, int repeat_count,
-           bool prev_state, bool modifier_shift_pressed,
-           bool modifier_ctrl_pressed, bool modifier_alt_pressed,
-           bool modifier_super_pressed)
+  KeyEvent(Window* target, int key_code, int repeat_count, bool prev_state,
+           bool modifier_shift_pressed, bool modifier_ctrl_pressed,
+           bool modifier_alt_pressed, bool modifier_super_pressed)
       : UIEvent(target),
-        virtual_key_(virtual_key),
+        key_code_(key_code),
         repeat_count_(repeat_count),
         prev_state_(prev_state),
         modifier_shift_pressed_(modifier_shift_pressed),
@@ -61,7 +58,7 @@ class KeyEvent : public UIEvent {
   bool is_handled() const { return handled_; }
   void set_handled(bool value) { handled_ = value; }
 
-  VirtualKey virtual_key() const { return virtual_key_; }
+  int key_code() const { return key_code_; }
 
   int repeat_count() const { return repeat_count_; }
   bool prev_state() const { return prev_state_; }
@@ -73,7 +70,7 @@ class KeyEvent : public UIEvent {
 
  private:
   bool handled_ = false;
-  VirtualKey virtual_key_ = VirtualKey::kNone;
+  int key_code_ = 0;
 
   int repeat_count_ = 0;
   bool prev_state_ = false;  // Key previously down(true) or up(false)
diff --git a/ui/window.cc b/ui/window.cc
index 74b81ae..e82b09f 100644
--- a/ui/window.cc
+++ b/ui/window.cc
@@ -259,21 +259,20 @@ void Window::OnLostFocus(UIEvent* e) {
 
 void Window::OnKeyPress(KeyEvent* e, bool is_down, bool is_char) {
   if (!is_char) {
-    switch (e->virtual_key()) {
-      case VirtualKey::kShift:
+    switch (e->key_code()) {
+      case 16:
         modifier_shift_pressed_ = is_down;
         break;
-      case VirtualKey::kControl:
+      case 17:
         modifier_cntrl_pressed_ = is_down;
         break;
-      case VirtualKey::kMenu:
-        modifier_alt_pressed_ = is_down;
-        break;
-      case VirtualKey::kLWin:
+      // case xx:
+      //  // alt ??
+      //  modifier_alt_pressed_ = is_down;
+      //  break;
+      case 91:
         modifier_super_pressed_ = is_down;
         break;
-      default:
-        break;
     }
   }
 }
@@ -353,5 +352,27 @@ void Window::OnMouseWheel(MouseEvent* e) {
   });
 }
 
+void Window::OnRawMouse(MouseEvent* e) {
+  on_raw_mouse(e);
+  if (e->is_handled()) {
+    return;
+  }
+  TryForEachListener([e](auto listener) {
+    listener->OnRawMouse(e);
+    return e->is_handled();
+  });
+}
+
+void Window::OnRawKeyboard(KeyEvent* e) {
+  on_raw_keyboard(e);
+  if (e->is_handled()) {
+    return;
+  }
+  TryForEachListener([e](auto listener) {
+    listener->OnRawKeyboard(e);
+    return e->is_handled();
+  });
+}
+
 }  // namespace ui
 }  // namespace xe
diff --git a/ui/window.h b/ui/window.h
index 2627c7c..d1d34d3 100644
--- a/ui/window.h
+++ b/ui/window.h
@@ -141,6 +141,9 @@ class Window {
   Delegate<MouseEvent*> on_mouse_up;
   Delegate<MouseEvent*> on_mouse_wheel;
 
+  Delegate<MouseEvent*> on_raw_mouse;
+  Delegate<KeyEvent*> on_raw_keyboard;
+
  protected:
   Window(WindowedAppContext& app_context, const std::string& title);
 
@@ -175,6 +178,9 @@ class Window {
   virtual void OnMouseUp(MouseEvent* e);
   virtual void OnMouseWheel(MouseEvent* e);
 
+  virtual void OnRawMouse(MouseEvent* e);
+  virtual void OnRawKeyboard(KeyEvent* e);
+
   void OnKeyPress(KeyEvent* e, bool is_down, bool is_char);
 
   WindowedAppContext& app_context_;
diff --git a/ui/window_demo.cc b/ui/window_demo.cc
index 05d6161..748cd9b 100644
--- a/ui/window_demo.cc
+++ b/ui/window_demo.cc
@@ -17,7 +17,6 @@
 #include "xenia/ui/graphics_provider.h"
 #include "xenia/ui/imgui_dialog.h"
 #include "xenia/ui/imgui_drawer.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/window.h"
 #include "xenia/ui/window_demo.h"
 
@@ -84,12 +83,10 @@ bool WindowDemoApp::OnInitialize() {
   });
 
   window_->on_key_down.AddListener([](xe::ui::KeyEvent* e) {
-    switch (e->virtual_key()) {
-      case VirtualKey::kF3:
+    switch (e->key_code()) {
+      case 0x72: {  // F3
         Profiler::ToggleDisplay();
-        break;
-      default:
-        break;
+      } break;
     }
   });
 
diff --git a/ui/window_gtk.cc b/ui/window_gtk.cc
index b35f913..d47972e 100644
--- a/ui/window_gtk.cc
+++ b/ui/window_gtk.cc
@@ -16,7 +16,6 @@
 #include "xenia/base/clock.h"
 #include "xenia/base/logging.h"
 #include "xenia/base/platform_linux.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/window_gtk.h"
 
 namespace xe {
@@ -407,10 +406,9 @@ bool GTKWindow::HandleKeyboard(GdkEventKey* event) {
   bool alt_pressed = modifiers & GDK_META_MASK;
   bool super_pressed = modifiers & GDK_SUPER_MASK;
   uint32_t key_char = gdk_keyval_to_unicode(event->keyval);
-  // TODO(Triang3l): event->hardware_keycode to VirtualKey translation.
-  auto e = KeyEvent(this, VirtualKey(event->hardware_keycode), 1,
-                    event->type == GDK_KEY_RELEASE, shift_pressed, ctrl_pressed,
-                    alt_pressed, super_pressed);
+  auto e =
+      KeyEvent(this, event->hardware_keycode, 1, event->type == GDK_KEY_RELEASE,
+               shift_pressed, ctrl_pressed, alt_pressed, super_pressed);
   switch (event->type) {
     case GDK_KEY_PRESS:
       OnKeyDown(&e);
diff --git a/ui/window_listener.h b/ui/window_listener.h
index 08f7a5c..d6aa494 100644
--- a/ui/window_listener.h
+++ b/ui/window_listener.h
@@ -47,6 +47,9 @@ class WindowListener {
   virtual void OnMouseMove(MouseEvent* e) {}
   virtual void OnMouseUp(MouseEvent* e) {}
   virtual void OnMouseWheel(MouseEvent* e) {}
+
+  virtual void OnRawMouse(MouseEvent* e) {}
+  virtual void OnRawKeyboard(KeyEvent* e) {}
 };
 
 }  // namespace ui
diff --git a/ui/window_win.cc b/ui/window_win.cc
index a6d2c68..7214131 100644
--- a/ui/window_win.cc
+++ b/ui/window_win.cc
@@ -17,7 +17,6 @@
 #include "xenia/base/filesystem.h"
 #include "xenia/base/logging.h"
 #include "xenia/base/platform_win.h"
-#include "xenia/ui/virtual_key.h"
 #include "xenia/ui/windowed_app_context_win.h"
 
 namespace xe {
@@ -128,6 +127,19 @@ bool Win32Window::OnCreate() {
   // Enable file dragging from external sources
   DragAcceptFiles(hwnd_, true);
 
+  // Enable raw input for mouse & keyboard
+  RAWINPUTDEVICE device;
+  device.usUsagePage = 0x01;  // HID_USAGE_PAGE_GENERIC
+  device.usUsage = 0x02;      // HID_USAGE_GENERIC_MOUSE
+  device.dwFlags = 0;
+  device.hwndTarget = 0;
+  RegisterRawInputDevices(&device, 1, sizeof(RAWINPUTDEVICE));
+  device.usUsagePage = 0x01;  // HID_USAGE_PAGE_GENERIC
+  device.usUsage = 0x06;      // HID_USAGE_GENERIC_KEYBOARD
+  device.dwFlags = 0;
+  device.hwndTarget = 0;
+  RegisterRawInputDevices(&device, 1, sizeof(RAWINPUTDEVICE));
+
   ShowWindow(hwnd_, SW_SHOWNORMAL);
   UpdateWindow(hwnd_);
 
@@ -277,6 +289,15 @@ void Win32Window::ToggleFullscreen(bool fullscreen) {
       AdjustWindowRect(&rc, GetWindowLong(hwnd_, GWL_STYLE), false);
       MoveWindow(hwnd_, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                  TRUE);
+
+      // Reduce cursor bounds by 1px on each side, just in case..
+      rc.top++;
+      rc.left++;
+      rc.bottom--;
+      rc.right--;
+
+      // Keep cursor inside the fullscreen window
+      ClipCursor(&rc);
     }
   } else {
     // Reinstate borders, resize to 1280x720
@@ -287,6 +308,9 @@ void Win32Window::ToggleFullscreen(bool fullscreen) {
     if (main_menu) {
       ::SetMenu(hwnd_, main_menu->handle());
     }
+
+    // Unbound the mouse cursor
+    ClipCursor(NULL);
   }
 
   fullscreen_ = fullscreen;
@@ -506,6 +530,149 @@ LRESULT Win32Window::WndProc(HWND hWnd, UINT message, WPARAM wParam,
   }
 
   switch (message) {
+    case WM_INPUT: {
+      HRAWINPUT hRawInput = (HRAWINPUT)lParam;
+      UINT dataSize = 0;
+
+      // Get size of the rawinput data
+      if (GetRawInputData(hRawInput, RID_INPUT, NULL, &dataSize,
+                          sizeof(RAWINPUTHEADER)) != 0 ||
+          dataSize == 0 || dataSize > sizeof(RAWINPUT)) {
+        // Unknown failure, exit out
+        assert_always();
+        break;
+      }
+
+      // Now get the actual data itself
+      if (GetRawInputData(hRawInput, RID_INPUT, &rawinput_data_, &dataSize,
+                          sizeof(RAWINPUTHEADER)) == (UINT)-1) {
+        // Another unknown failure
+        assert_always();
+        break;
+      }
+
+      if (rawinput_data_.header.dwType == RIM_TYPEMOUSE) {
+        const auto& mouseData = rawinput_data_.data.mouse;
+
+        auto e = MouseEvent(this, MouseEvent::Button::kNone, mouseData.lLastX,
+                            mouseData.lLastY, mouseData.usButtonFlags,
+                            (int16_t)mouseData.usButtonData);
+        OnRawMouse(&e);
+        return 0;
+      } else if (rawinput_data_.header.dwType == RIM_TYPEKEYBOARD) {
+        const auto& keyData = rawinput_data_.data.keyboard;
+
+        // Adjust VK code passed to handlers
+        // Based on
+        // https://blog.molecular-matters.com/2011/09/05/properly-handling-keyboard-input/
+        auto vkey = keyData.VKey;
+        bool isE0 = (keyData.Flags & RI_KEY_E0) != 0;
+
+        // discard "fake keys" which are part of an escaped sequence
+        if (vkey == 255) {
+          return 0;
+        } else if (vkey == VK_SHIFT) {
+          // correct left-hand / right-hand SHIFT
+          vkey = MapVirtualKey(keyData.MakeCode, MAPVK_VSC_TO_VK_EX);
+        } else {
+          switch (vkey) {
+            // right-hand CONTROL and ALT have their e0 bit set
+            case VK_CONTROL:
+              vkey = isE0 ? VK_RCONTROL : VK_LCONTROL;
+              break;
+
+            case VK_MENU:
+              vkey = isE0 ? VK_RMENU : VK_LMENU;
+              break;
+
+            case VK_RETURN:
+              if (isE0) {
+                vkey = VK_SEPARATOR;
+              }
+              break;
+
+            // the standard INSERT, DELETE, HOME, END, PRIOR and NEXT keys will
+            // always have their e0 bit set, but the corresponding keys on the
+            // NUMPAD will not.
+            case VK_INSERT:
+              if (!isE0) {
+                vkey = VK_NUMPAD0;
+              }
+              break;
+
+            case VK_DELETE:
+              if (!isE0) {
+                vkey = VK_DECIMAL;
+              }
+              break;
+
+            case VK_HOME:
+              if (!isE0) {
+                vkey = VK_NUMPAD7;
+              }
+              break;
+
+            case VK_END:
+              if (!isE0) {
+                vkey = VK_NUMPAD1;
+              }
+              break;
+
+            case VK_PRIOR:
+              if (!isE0) {
+                vkey = VK_NUMPAD9;
+              }
+              break;
+
+            case VK_NEXT:
+              if (!isE0) {
+                vkey = VK_NUMPAD3;
+              }
+              break;
+
+            // the standard arrow keys will always have their e0 bit set, but
+            // the corresponding keys on the NUMPAD will not.
+            case VK_LEFT:
+              if (!isE0) {
+                vkey = VK_NUMPAD4;
+              }
+              break;
+
+            case VK_RIGHT:
+              if (!isE0) {
+                vkey = VK_NUMPAD6;
+              }
+              break;
+
+            case VK_UP:
+              if (!isE0) {
+                vkey = VK_NUMPAD8;
+              }
+              break;
+
+            case VK_DOWN:
+              if (!isE0) {
+                vkey = VK_NUMPAD2;
+              }
+              break;
+
+            // NUMPAD 5 doesn't have its e0 bit set
+            case VK_CLEAR:
+              if (!isE0) {
+                vkey = VK_NUMPAD5;
+              }
+              break;
+          }
+        }
+
+        auto e = KeyEvent(this, vkey, 0, !(keyData.Flags & RI_KEY_BREAK), false,
+                          false, false, false);
+
+        OnRawKeyboard(&e);
+        return 0;
+      }
+
+    } break;
     case WM_DROPFILES: {
       HDROP drop_handle = reinterpret_cast<HDROP>(wParam);
       auto drop_count = DragQueryFileW(drop_handle, 0xFFFFFFFFu, nullptr, 0);
@@ -603,6 +770,20 @@ LRESULT Win32Window::WndProc(HWND hWnd, UINT message, WPARAM wParam,
       has_focus_ = true;
       auto e = UIEvent(this);
       OnGotFocus(&e);
+
+      if (is_fullscreen()) {
+        // Cursor bounds can be lost when focus is lost, reapply them...
+        // TODO: can this go somewhere better?
+        RECT bounds;
+        GetWindowRect(hwnd(), &bounds);
+        // Reduce cursor bounds by 1px on each side, just in case..
+        bounds.top++;
+        bounds.left++;
+        bounds.bottom--;
+        bounds.right--;
+        ClipCursor(&bounds);
+      }
+
       break;
     }
 
@@ -717,7 +898,7 @@ bool Win32Window::HandleMouse(UINT message, WPARAM wParam, LPARAM lParam) {
 
 bool Win32Window::HandleKeyboard(UINT message, WPARAM wParam, LPARAM lParam) {
   auto e = KeyEvent(
-      this, VirtualKey(wParam), lParam & 0xFFFF0000, !!(lParam & 0x2),
+      this, static_cast<int>(wParam), lParam & 0xFFFF0000, !!(lParam & 0x2),
       !!(GetKeyState(VK_SHIFT) & 0x80), !!(GetKeyState(VK_CONTROL) & 0x80),
       !!(GetKeyState(VK_MENU) & 0x80), !!(GetKeyState(VK_LWIN) & 0x80));
   switch (message) {
diff --git a/ui/window_win.h b/ui/window_win.h
index f4dceae..738b68a 100644
--- a/ui/window_win.h
+++ b/ui/window_win.h
@@ -90,6 +90,8 @@ class Win32Window : public Window {
   WINDOWPLACEMENT windowed_pos_ = {0};
   POINT last_mouse_pos_ = {0};
 
+  RAWINPUT rawinput_data_;
+
   void* GetDpiForMonitor_ = nullptr;
 };
 
